# encoding: utf-8

module OpenCL
    module Compiler
        grammar RubyExpression
            include RubyIdentifier

            rule compound_statement
                stmts ss0 <BlockNode>
            end

            rule stmts
                fs:stmt rs:(ss1 stmt)* {
                    # stmts can only be the body of block node, so no tag
                    # for it.
                    # see, BlockNode#to_sexp
                    def to_sexp
                        [fs.to_sexp] +
                        rs.elements.map do |elm|
                            elm.stmt.to_sexp
                        end
                    end
                }
            end

            rule stmt
                expr:(keyword_logical_expr / command) ms:modifier_stmt? {
                    def to_sexp
                        exp = expr.to_sexp
                        ms.empty? ? exp : ms.to_sexp(exp)
                    end
                }
            end

            rule keyword_logical_expr
                expression le:(hs1 kw:('and' / 'or') (hs1 / ls1) expression)* {
                    def to_sexp
                        exp = expression.to_sexp
                        return exp if le.empty?

                        le.elements.each do |elm|
                            exp = [elm.kw.text_value.to_sym, exp, elm.expression.to_sexp]
                        end
                        exp
                    end
                }
            end

            rule expression
                keyword_not_expr
                / expr
            end

            rule command
                # NOTE: 'redo' and 'retry' are not supported (yet?).
                cmd:('next' / 'break' / 'return') hs1 expression {
                    def to_sexp
                        [cmd.text_value.to_sym, expression.to_sexp]
                    end
                }
            end

            rule modifier_stmt
                hs1 modifier ms:modifier_stmt? {
                    def to_sexp(body)
                        exp = modifier.to_sexp(body)
                        ms.empty? ? exp : ms.to_sexp(exp)
                    end
                }
            end

            rule modifier
                pre:('if'
                 / 'unless'
                 / 'while'
                 / 'until') (ls1 / hs1) keyword_logical_expr {
                    def to_sexp(body)
                        [pre.text_value.to_sym, [:cond, keyword_logical_expr.to_sexp],
                                                [:body, body]]
                    end
                 }
            end

            rule keyword_not_expr
                'not' (hs1 / ls1) !(iter_expr / bool_expr) expression {
                    def to_sexp
                        [:not, expression.to_sexp]
                    end
                }
            end

            rule expr
                message_with_open_arags
                / not_paren_expr
                / assignment
                / ternary_expr
                / arith_expr
                / primary_expr
            end

            rule message_with_open_arags
                message hs0 open_arg_list {
                    def to_sexp
                        [:call, message.library,
                                message.var.text_value,
                                open_arg_list.to_sexp]
                    end
                }
            end

            rule message
                lib:(constant '.')? var {
                    def library
                        lib.empty? ? nil : lib.constant.text_value
                    end
                }
            end

            rule open_arg_list
                expr ral:(hs0 ',' ls0 expr)* {
                    def to_sexp
                        [:args, expr.to_sexp] +
                        ral.elements.map do |elm|
                            elm.expr.to_sexp
                        end
                    end
                }
            end

            rule close_arg_list
                '(' ls0 arg_list ls0 ')' {
                    def to_sexp
                        arg_list.to_sexp
                    end
                }
            end

            rule arg_list
                open_arg_list
                / close_arg_list
            end

            rule not_paren_expr
                'not' paren_expr {
                    def to_sexp
                        [:not, paren_expr.to_sexp]
                    end
                }
            end

            rule assignment
                assign
                / op_assign
            end

            rule assign
                lvar hs0 '=' ls0 arg_list {
                    def to_sexp
                        [:assign, lvar.to_sexp, arg_list.to_sexp]
                    end
                }
            end

            rule op_assign
                lvar hs0 assign_op ls0 expr {
                    def to_sexp
                        [:call, assign_op.text_value, lvar.to_sexp, expr.to_sexp]
                    end
                }
            end

            rule assign_op
                '+=' / '-=' / '*=' / '/='
            end

            rule ternary_expr
                arith_expr hs1 '?' hs0 true_exp:(assignment # FIXME: duplication with definiton of rule expr
                / ternary_expr
                / arith_expr
                / primary_expr) hs0 ':' hs0 expr {
                    def to_sexp
                        [:if, [:cond, arith_expr.to_sexp],
                              [:body, true_exp.to_sexp],
                              [:else_body, expr.to_sexp]]
                    end
                }
            end

            rule arith_expr
                lhs:and_expr rhs:(hs0 op:'||' ss0 rhs:and_expr)* <BinaryArithExressionNode>
            end

            rule and_expr
                lhs:equality_expr rhs:(hs0 op:'&&' ss0 rhs:equality_expr)* <BinaryArithExressionNode>
            end

            rule equality_expr
                lhs:ordering_expr rhs:(hs0 op:equality_op ss0 rhs:ordering_expr)* <BinaryArithExressionNode>
            end

            rule equality_op
                '==' / '!='
            end

            rule ordering_expr
                lhs:bit_or_expr rhs:(hs0 op:ordering_op ss0 rhs:bit_or_expr)* <BinaryArithExressionNode>
            end

            rule ordering_op
                '>=' / '<=' / '>' / '<'
            end

            rule bit_or_expr
                lhs:bit_and_expr rhs:(hs0 op:bit_or_op ss0 rhs:bit_and_expr)* <BinaryArithExressionNode>
            end

            rule bit_or_op
                '|' / '^'
            end

            rule bit_and_expr
                lhs:bit_shift_expr rhs:(hs0 op:bit_and_op ss0 rhs:bit_shift_expr)* <BinaryArithExressionNode>
            end

            rule bit_and_op
                '&'
            end

            rule bit_shift_expr
                lhs:add_sub_expr rhs:(hs0 op:bit_shift_op ss0 rhs:add_sub_expr)* <BinaryArithExressionNode>
            end

            rule bit_shift_op
                '<<' / '>>'
            end

            rule add_sub_expr
                lhs:mul_div_expr rhs:(hs0 op:add_sub_op ss0 rhs:mul_div_expr)* <BinaryArithExressionNode>
            end

            rule add_sub_op
                '+' / '-'
            end

            rule mul_div_expr
                lhs:minus_expr rhs:(hs0 op:mul_div_op ss0 rhs:minus_expr)* <BinaryArithExressionNode>
            end

            rule mul_div_op
                '*' / '/' / '%'
            end

            rule minus_expr
                op:('-' hs0)? pow_expr  {
                    def to_sexp
                        sexp = pow_expr.to_sexp
                        op.empty? ? sexp : [:negative, sexp]
                    end
                }
            end

            rule pow_expr
                lhs:not_expr rhs:(hs0 op:pow_op ss0 rhs:not_expr)* <BinaryArithExressionNode>
            end

            rule pow_op
                '**'
            end

            rule not_expr
                op:('!' / '~' / '+')? primary_expr  {
                    def to_sexp
                        sexp = primary_expr.to_sexp
                        return sexp if op.empty?

                        tag = op.text_value.to_sym
                        tag = :pos if tag == '+'
                        [tag, sexp]
                    end
                }
            end

            rule primary_expr
                message_with_close_args
                / literal
                / symbol
                / lvar
                / paren_expr
                / begin_block_expr
                / iter_expr
                / bool_expr
            end

            rule literal
                number
                / true
                / false
                / nil
            end

            rule symbol
                ':' word {
                    def to_sexp
                        [:symbol, self.text_value.to_sym]
                    end
                }
            end

            rule lvar
                array_ref
                / vector_ref
                / var
            end

            rule array_ref
                var hs0 '[' hs0 array_sub ls0 ']'  {
                    def to_sexp
                        ['[]'.to_sym, array_sub.to_sexp]
                    end
                }
            end

            rule array_sub
                symbol / number / var
            end

            rule vector_ref
                var comp:('.' vector_component_name)+  {
                    def to_sexp
                        sexp = var.to_sexp
                        comp.elements.each do |elm|
                            sexp = [:call, 'vector_ref', sexp, elm.vector_component_name.text_value]
                        end
                        sexp
                    end
                }
            end

            rule vector_component_name
                [w-zW-Z] 1..16
                / [sS] [0-9a-fA-F] 1..16
                / 'hi'
                / 'lo'
                / 'even'
                / 'odd'
            end

            rule paren_expr
                '(' ss0 stmts ss0 ')' <BlockNode>
            end

            rule begin_block_expr
                'begin' (hs1 / ss1) stmts (hs1 / ss1) 'end' <BlockNode>
            end

            rule message_with_close_args
                message hs0 close_arg_list  {
                    def to_sexp
                        [:call, :lib, message.lib.text_value,
                                :fun, message.var.text_value,
                                close_arg_list.to_sexp]
                    end
                }
            end

            rule iter_expr
                while_loop
                / until_loop
            end

            rule while_loop
                'while' hs0 keyword_logical_expr loop_body  {
                    def to_sexp
                        [:while, [:cond, keyword_logical_expr.to_sexp],
                                 [:body, loop_body.to_sexp]]
                    end
                }
            end

            rule until_loop
                'until' hs0 keyword_logical_expr loop_body  {
                    def to_sexp
                        [:while, [:cond, [:not, keyword_logical_expr.to_sexp]],
                                 [:body, loop_body.to_sexp]]
                    end
                }
            end

            rule loop_body
                ((hs1 'do' (ss1 / hs1)) / ss1) stmts (ss1 / hs1) 'end' <BlockNode>
            end

            rule bool_expr
                if_expr
                / unless_expr
                / case_expr
            end

            rule if_expr
                'if' hs0 keyword_logical_expr then_body eib:elsif_body* eb:else_body? 'end'  {
                    def to_sexp
                        sexp = [:if, [:cond, keyword_logical_expr.to_sexp],
                                     [:then, then_body.to_sexp],
                                     [:elsif_bodies, eib.elements.map(&:to_sexp)]]
                        sexp += [:else, eb.to_sexp] unless eb.empty?
                        sexp
                    end
                }
            end

            rule then_body
                ((hs1 'then' (ss1 / hs1)) / ss1) stmts (ss1 / hs1) <BlockNode>
            end

            rule elsif_body
                'elsif' hs0 keyword_logical_expr then_body  {
                    def to_sexp
                        [:elsif, [:cond, keyword_logical_expr.to_sexp],
                                 [:then, then_body.to_sexp]]
                    end
                }
            end

            rule else_body
                'else' (ss1 / hs1) stmts (ss1 / hs1) <BlockNode>
            end

            rule unless_expr
                'unless' hs0 keyword_logical_expr then_body eb:else_body? 'end'  {
                    def to_sexp
                        sexp = [:if, [:cond, [:not, keyword_logical_expr.to_sexp]],
                                     [:then_body, then_body.to_sexp]]
                        sexp += [:else_body, eb.to_sexp] unless eb.empty?
                        sexp
                    end
                }
            end

            rule case_expr
                'case' hs0 keyword_logical_expr ss1 when_body+ else_body? 'end'  {
                    def to_sexp
                        [:case, keyword_logical_expr.to_sexp]
                    end
                }
            end

            rule when_body
                'when' hs0 arg_list then_body  {
                    def to_sexp
                        [:when]
                    end
                }
            end
        end
    end
end
