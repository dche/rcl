# encoding: utf-8

module OpenCL
  module Compiler
    # A Sexp object is an Array that represents a piece of Ruby code,
    # and be able to compile itself to another language by calling
    # corresponding sexp processors of the target language.
    #
    # Sexp object is generated by traversing the syntax node tree generated
    # by treetop parser.
    #
    # A Sexp is in the form, [tag, (String | Symbol | Sexp)*].
    # See grammar/block.treetop and grammar/expression.treetop for details.
    module Sexp
      def self.extended(obj)
        raise TypeError, "malformed s-exp" unless obj.is_a?(Array)
        obj.body.each do |elm|
          elm.extend(self) if elm.is_a?(Array)
        end
      end

      # Set/get attributes of the receiver.
      #
      # Example,
      #   sexp.attribute(:type, :int)
      #   sexp.attribute(:type) # => :int
      #
      # Type inferrers and translators can add any attributes to a Sexp.
      def attribute(name, value = nil)
        @attributes ||= {}
        value.nil? ? @attributes[name] : @attributes[name] = value
      end

      def tag
        self.first
      end
      alias :head :tag

      def body
        self[1..-1] || []
      end
      alias :rest :body

      def method_missing(meth, *args, &blk)
        b = nil
        self.body.each do |elm|
          next unless elm.is_a?(Sexp)
          if elm.tag == meth
            b = elm
            break
          end
        end
        b.nil? ? super : b
      end

      def respond_to?(symbol)
        self.body.each do |elm|
          next unless elm.is_a?(Sexp)
          if elm.tag == symbol
            return true
          end
        end
        super
      end

      def print
        src = self.body.map do |elm|
          case elm
          when Sexp
            elm.print
          when String
            "\"#{elm.to_s}\""
          when Symbol
            ":#{elm.to_s}"
          else
            elm.to_s
          end
        end.join("\n")
        src = rshift src, 3

        "(#{self.tag}\n#{src})"
      end

      private

      def rshift(str, n)
        return str if str.empty? || n < 1

        str.lines.map do |s|
          " " * n + s
        end.join
      end
    end
  end
end

