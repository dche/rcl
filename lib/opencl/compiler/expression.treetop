
module OpenCL
    module Compiler
        grammar RubyExpression
            include RubyIdentifier

            rule compound_statement
                stmts ss0 {

                }
            end

            rule stmts
                stmt (ss1 stmt)*
            end

            rule stmt
                expression (hs1 modifier_stmt)?
                / command
            end

            rule expression
                'not' hs1 expression
                / expr (hs1 infix_logical_expr)?
            end

            rule modifier_stmt
                modifier (hs1 modifier)*
            end

            rule modifier
                if_modifier
                / unless_modifier
                / while_modifier
                / until_modifier
            end

            rule if_modifier
                'if' (ls1 / hs1) expression
            end

            rule unless_modifier
                'unless' (ls1 / hs1) expression
            end

            rule while_modifier
                'while' (ls1 / hs1) expression
            end

            rule until_modifier
                'until' (ls1 / hs1) expression
            end

            rule command
                'next' ret_val?
                / 'break' ret_val?
                / 'return' ret_val?
                / 'redo'
                / 'retry'
            end

            rule ret_val
                hs1 expression
            end

            rule expr
                message_with_open_arags
                / 'not' paren_expr
                / assignment
                / ternary_expr
                / arith_expr
                / primary_expr
            end

            rule message_with_open_arags
                message hs0 open_arg_list
            end

            rule message
                (constant '.')? lvar
            end

            rule open_arg_list
                expression rest_arg_list?
            end

            rule arg_list
                close_arg_list
                / open_arg_list
            end

            rule rest_arg_list
                hs0 ',' ls0 expression rest_arg_list?
            end

            rule infix_logical_expr
                'and' hs0 expression
                / 'or' hs0 expression
            end

            rule assignment
                lvar hs0 op_assign ls0 expr
            end

            rule op_assign
                '=' / '+=' / '-=' / '*=' / '/='
            end

            rule ternary_expr
                arith_expr hs1 '?' hs0 (assignment # FIXME: duplication with definiton of rule expr
                / ternary_expr
                / arith_expr
                / primary_expr) hs0 ':' hs0 expr
            end

            rule arith_expr
                and_expr (hs0 '||' ss0 and_expr)?
            end

            rule and_expr
                equality_expr (hs0 '&&' ss0 equality_expr)?
            end

            rule equality_expr
                ordering_expr (equality_op ordering_expr)?
            end

            rule equality_op
                hs0 ('==' / '!=') ss0
            end

            rule ordering_expr
                bit_or_expr (ordering_op bit_or_expr)?
            end

            rule ordering_op
                hs0 ('>=' / '<=' / '>' / '<') ss0
            end

            rule bit_or_expr
                bit_and_expr (bit_or_op bit_and_expr)?
            end

            rule bit_or_op
                hs0 ('|' / '^') ss0
            end

            rule bit_and_expr
                bit_shift_expr (bit_and_op bit_shift_expr)?
            end

            rule bit_and_op
                hs0 '&' ss0
            end

            rule bit_shift_expr
                add_sub_expr (bit_shift_op add_sub_expr)?
            end

            rule bit_shift_op
                hs0 ('<<' / '>>') ss0
            end

            rule add_sub_expr
                mul_div_expr (add_sub_op mul_div_expr)?
            end

            rule add_sub_op
                hs0 ('+' / '-') ss0
            end

            rule mul_div_expr
                minus_expr (mul_div_op minus_expr)?
            end

            rule mul_div_op
                hs0 ('*' / '/' / '%') ss0
            end

            rule minus_expr
                ('-' hs0)? pow_expr
            end

            rule pow_expr
                not_expr (pow_op not_expr)?
            end

            rule pow_op
                hs0 '**' ss0
            end

            rule not_expr
                ('!' / '~' / '+')? primary_expr
            end

            rule primary_expr
                message_with_close_args
                / value
                / paren_expr
                / begin_block_expr
                / iter_expr
                / bool_expr
            end

            rule value
                literal
                / lvar
            end

            rule literal
                num_literal
                / symbol
                / true
                / false
                / nil
            end

            rule paren_expr
                '(' ss0 stmts ss0 ')'
            end

            rule begin_block_expr
                'begin' (hs1 / ss1) stmts (hs1 / ss1) 'end'
            end

            rule message_with_close_args
                message hs0 close_arg_list
            end

            rule close_arg_list
                '(' (ls0 / hs1) arg_list (ls0 / hs1) ')'
            end

            rule iter_expr
                while_loop
                / until_loop
            end

            rule while_loop
                'while' hs0 expression loop_body
            end

            rule until_loop
                'until' hs0 expression loop_body
            end

            rule loop_body
                ((hs1 'do' (ss1 / hs1)) / ss1) stmts (ss1 / hs1) 'end'
            end

            rule bool_expr
                if_expr
                / unless_expr
                / case_expr
            end

            rule if_expr
                'if' hs0 expression then_body elsif_body* else_body? 'end'
            end

            rule then_body
                ((hs1 'then' (ss1 / hs1)) / ss1) stmts (ss1 / hs1)
            end

            rule elsif_body
                'elsif' hs0 expression then_body
            end

            rule else_body
                'else' (ss1 / hs1) stmts (ss1 / hs1)
            end

            rule unless_expr
                'unless' hs0 expression then_body else_body? 'end'
            end

            rule case_expr
                'case' hs0 expression ss1 when_body+ else_body? 'end'
            end

            rule when_body
                'when' hs0 arg_list then_body
            end
        end
    end
end
